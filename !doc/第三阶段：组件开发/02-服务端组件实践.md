# 服务端组件实践

## 2.1 回顾：服务端组件基础

在 Next.js App Router 中，**默认所有组件都是服务端组件**。

### 服务端组件的特点

**✅ 优势：**
- 在服务器上运行，减少客户端 JavaScript 体积
- 可以直接访问数据库、文件系统、环境变量
- 更快的首屏加载（数据已包含在 HTML 中）
- SEO 友好（内容在服务端渲染）

**❌ 限制：**
- 不能使用浏览器 API（如 `window`、`localStorage`）
- 不能使用 React Hooks（如 `useState`、`useEffect`）
- 不能使用事件处理器（如 `onClick`）

---

## 2.2 创建服务端组件获取数据

### 示例 1：从 API 获取数据

**创建组件：** `app/components/ServerUserList.tsx`

```typescript
// app/components/ServerUserList.tsx
// 注意：这是服务端组件，不需要 'use client'

interface User {
  id: number
  name: string
  email: string
}

// ✅ 可以使用 async
export default async function ServerUserList() {
  // ✅ 可以直接使用 await 获取数据
  const response = await fetch('https://jsonplaceholder.typicode.com/users', {
    // 在服务端组件中，fetch 默认会缓存
    // 如果需要实时数据，可以设置 cache: 'no-store'
    cache: 'no-store', // 或者 'force-cache'（默认）
  })
  
  if (!response.ok) {
    throw new Error('获取用户数据失败')
  }
  
  const users: User[] = await response.json()
  
  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">用户列表（服务端组件）</h2>
      <ul className="space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-4 border rounded">
            <p className="font-semibold">{user.name}</p>
            <p className="text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

**使用示例：**

```typescript
// app/users/page.tsx
import ServerUserList from '@/app/components/ServerUserList'

export default function UsersPage() {
  return (
    <div className="container mx-auto p-8">
      <h1 className="text-3xl font-bold mb-8">用户页面</h1>
      <ServerUserList />
    </div>
  )
}
```

---

### 示例 2：从数据库获取数据

**创建数据库工具函数：** `app/lib/db.ts`

```typescript
// app/lib/db.ts
// 这是一个模拟的数据库函数
// 在实际项目中，你会使用真实的数据库（如 SQLite、PostgreSQL 等）

export interface Post {
  id: number
  title: string
  content: string
  author: string
  createdAt: string
}

// 模拟数据库数据
const mockPosts: Post[] = [
  {
    id: 1,
    title: 'Next.js 入门指南',
    content: '这是一篇关于 Next.js 入门的文章...',
    author: '张三',
    createdAt: '2024-01-01',
  },
  {
    id: 2,
    title: 'React Server Components 详解',
    content: 'React Server Components 是 React 的新特性...',
    author: '李四',
    createdAt: '2024-01-02',
  },
]

// 模拟数据库查询函数
export async function getPosts(): Promise<Post[]> {
  // 模拟网络延迟
  await new Promise((resolve) => setTimeout(resolve, 100))
  return mockPosts
}

export async function getPostById(id: number): Promise<Post | null> {
  await new Promise((resolve) => setTimeout(resolve, 100))
  return mockPosts.find((post) => post.id === id) || null
}
```

**创建服务端组件：** `app/components/ServerPostList.tsx`

```typescript
// app/components/ServerPostList.tsx
import { getPosts } from '@/app/lib/db'
import Card from '@/app/components/ui/Card'

export default async function ServerPostList() {
  // ✅ 在服务端组件中直接调用数据库函数
  const posts = await getPosts()
  
  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">文章列表（服务端组件）</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {posts.map((post) => (
          <Card key={post.id} title={post.title}>
            <p className="text-gray-600 mb-2">{post.content}</p>
            <div className="flex justify-between text-sm text-gray-500">
              <span>作者：{post.author}</span>
              <span>日期：{post.createdAt}</span>
            </div>
          </Card>
        ))}
      </div>
    </div>
  )
}
```

---

### 示例 3：使用环境变量

**创建组件：** `app/components/ServerConfig.tsx`

```typescript
// app/components/ServerConfig.tsx
// 注意：环境变量只在服务端组件中安全使用

export default function ServerConfig() {
  // ✅ 可以直接访问环境变量
  const apiUrl = process.env.NEXT_PUBLIC_API_URL || '未设置'
  const nodeEnv = process.env.NODE_ENV
  
  // ⚠️ 注意：只有以 NEXT_PUBLIC_ 开头的环境变量才会暴露给客户端
  // 其他环境变量只在服务端可用，更安全
  
  return (
    <div className="p-4 bg-gray-100 rounded">
      <h3 className="font-bold mb-2">环境配置（服务端组件）</h3>
      <p>API URL: {apiUrl}</p>
      <p>Node Environment: {nodeEnv}</p>
      <p className="text-sm text-gray-600 mt-2">
        ⚠️ 这些信息只在服务端可见，不会暴露给客户端
      </p>
    </div>
  )
}
```

---

## 2.3 理解服务端组件的限制

### 限制 1：不能使用 React Hooks

```typescript
// ❌ 错误示例
export default function ServerComponent() {
  const [count, setCount] = useState(0) // ❌ 不能使用 useState
  useEffect(() => { ... }) // ❌ 不能使用 useEffect
  
  return <div>{count}</div>
}

// ✅ 正确做法：使用客户端组件
'use client'
import { useState } from 'react'

export default function ClientComponent() {
  const [count, setCount] = useState(0)
  return <div>{count}</div>
}
```

### 限制 2：不能使用事件处理器

```typescript
// ❌ 错误示例
export default function ServerComponent() {
  return (
    <button onClick={() => alert('点击')}> // ❌ 不能使用 onClick
      点击我
    </button>
  )
}

// ✅ 正确做法：使用客户端组件
'use client'
export default function ClientComponent() {
  return (
    <button onClick={() => alert('点击')}>
      点击我
    </button>
  )
}
```

### 限制 3：不能使用浏览器 API

```typescript
// ❌ 错误示例
export default function ServerComponent() {
  const width = window.innerWidth // ❌ 不能使用 window
  const data = localStorage.getItem('key') // ❌ 不能使用 localStorage
  
  return <div>{width}</div>
}

// ✅ 正确做法：在客户端组件中使用
'use client'
'use effect'
import { useState, useEffect } from 'react'

export default function ClientComponent() {
  const [width, setWidth] = useState(0)
  
  useEffect(() => {
    setWidth(window.innerWidth)
    const data = localStorage.getItem('key')
  }, [])
  
  return <div>{width}</div>
}
```

---

## 2.4 服务端组件的优势实践

### 优势 1：减少客户端 JavaScript

**服务端组件：**

```typescript
// app/components/ServerData.tsx
// 这个组件的代码不会发送到客户端
export default async function ServerData() {
  const data = await fetchData() // 在服务器上执行
  return <div>{data}</div>
}
```

**客户端组件（对比）：**

```typescript
// app/components/ClientData.tsx
'use client'
// 这个组件的代码会发送到客户端
import { useEffect, useState } from 'react'

export default function ClientData() {
  const [data, setData] = useState(null)
  
  useEffect(() => {
    fetchData().then(setData) // 在客户端执行
  }, [])
  
  return <div>{data}</div>
}
```

**对比结果：**
- 服务端组件：JavaScript 体积更小，首屏加载更快
- 客户端组件：需要额外的 JavaScript 代码，首屏加载较慢

---

### 优势 2：SEO 友好

服务端组件在服务器上渲染，HTML 内容直接包含在响应中，搜索引擎可以直接抓取。

```typescript
// app/components/ServerSEO.tsx
export default async function ServerSEO() {
  const posts = await getPosts()
  
  return (
    <div>
      {/* 这些内容会直接出现在 HTML 中，SEO 友好 */}
      {posts.map((post) => (
        <article key={post.id}>
          <h1>{post.title}</h1>
          <p>{post.content}</p>
        </article>
      ))}
    </div>
  )
}
```

---

## 2.5 实际应用示例

### 示例：创建一个博客列表页面

**创建页面：** `app/blog/page.tsx`

```typescript
// app/blog/page.tsx
import { getPosts } from '@/app/lib/db'
import Card from '@/app/components/ui/Card'
import Link from 'next/link'

export default async function BlogPage() {
  // ✅ 在服务端组件中直接获取数据
  const posts = await getPosts()
  
  return (
    <div className="container mx-auto p-8">
      <h1 className="text-3xl font-bold mb-8">博客列表</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {posts.map((post) => (
          <Card key={post.id} title={post.title}>
            <p className="text-gray-600 mb-4 line-clamp-3">
              {post.content}
            </p>
            <div className="flex justify-between items-center">
              <span className="text-sm text-gray-500">
                {post.author} · {post.createdAt}
              </span>
              <Link
                href={`/blog/${post.id}`}
                className="text-blue-500 hover:text-blue-700"
              >
                阅读更多 →
              </Link>
            </div>
          </Card>
        ))}
      </div>
    </div>
  )
}
```

---

## 2.6 服务端组件最佳实践

### 实践 1：默认使用服务端组件

```typescript
// ✅ 推荐：默认使用服务端组件
export default async function DataComponent() {
  const data = await fetchData()
  return <div>{data}</div>
}

// ❌ 不推荐：除非需要交互，否则不要使用客户端组件
'use client'
export default function DataComponent() {
  // 不必要的客户端组件
}
```

### 实践 2：在服务端组件中获取数据

```typescript
// ✅ 推荐：在服务端组件中获取数据
export default async function UserProfile({ userId }: { userId: string }) {
  const user = await getUserById(userId)
  return <div>{user.name}</div>
}

// ❌ 不推荐：在客户端组件中获取数据（除非需要实时更新）
'use client'
export default function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState(null)
  useEffect(() => {
    getUserById(userId).then(setUser)
  }, [userId])
  return <div>{user?.name}</div>
}
```

### 实践 3：合理使用缓存

```typescript
// ✅ 使用缓存（默认行为）
export default async function CachedData() {
  const data = await fetch('https://api.example.com/data')
  // 默认会缓存，适合不经常变化的数据
  return <div>{data}</div>
}

// ✅ 不使用缓存（实时数据）
export default async function RealtimeData() {
  const data = await fetch('https://api.example.com/data', {
    cache: 'no-store', // 不缓存，每次都获取最新数据
  })
  return <div>{data}</div>
}

// ✅ 使用重新验证时间
export default async function TimeBasedData() {
  const data = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 }, // 每 3600 秒（1小时）重新验证
  })
  return <div>{data}</div>
}
```

---

## 2.7 常见问题解答

### Q1：服务端组件可以嵌套客户端组件吗？

**A：** 可以！服务端组件可以导入和使用客户端组件。

```typescript
// ✅ 服务端组件
export default async function ServerComponent() {
  const data = await fetchData()
  
  return (
    <div>
      <h1>{data.title}</h1>
      {/* 可以嵌套客户端组件 */}
      <ClientButton />
    </div>
  )
}

// 客户端组件
'use client'
export default function ClientButton() {
  return <button onClick={() => alert('点击')}>按钮</button>
}
```

### Q2：客户端组件可以嵌套服务端组件吗？

**A：** 不可以！客户端组件不能直接导入服务端组件。

```typescript
// ❌ 错误：客户端组件不能导入服务端组件
'use client'
import ServerComponent from './ServerComponent' // ❌ 错误

export default function ClientComponent() {
  return <ServerComponent />
}

// ✅ 正确做法：将服务端组件作为 props 传递
'use client'
export default function ClientComponent({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>
}

// 在父组件中使用
export default function ParentComponent() {
  return (
    <ClientComponent>
      <ServerComponent /> {/* ✅ 作为 children 传递 */}
    </ClientComponent>
  )
}
```

### Q3：如何判断应该使用服务端组件还是客户端组件？

**A：** 使用以下决策树：

```
需要交互性（onClick、onChange 等）？
├─ 是 → 使用客户端组件
└─ 否 → 需要 React Hooks（useState、useEffect）？
    ├─ 是 → 使用客户端组件
    └─ 否 → 需要浏览器 API（window、localStorage）？
        ├─ 是 → 使用客户端组件
        └─ 否 → 使用服务端组件（默认）
```

---

## 2.8 总结

### 关键要点

1. **默认使用服务端组件**：除非需要交互性，否则使用服务端组件
2. **直接获取数据**：在服务端组件中使用 `async/await` 直接获取数据
3. **理解限制**：不能使用 Hooks、事件处理器、浏览器 API
4. **利用优势**：减少客户端 JavaScript、SEO 友好、更快的首屏加载

### 下一步

完成服务端组件实践后，可以学习客户端组件实践，了解如何使用 React Hooks 创建交互式组件。

---

**学习进度：** ✅ 服务端组件实践完成

