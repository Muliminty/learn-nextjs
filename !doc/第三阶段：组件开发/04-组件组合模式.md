# 组件组合模式

## 4.1 什么是组件组合？

组件组合是 React 的核心概念，通过将小组件组合成更大的组件来构建用户界面。

### 组合的优势

- ✅ **可复用性**：组件可以在多个地方使用
- ✅ **可维护性**：每个组件职责单一，易于维护
- ✅ **灵活性**：通过 props 和 children 实现灵活组合
- ✅ **可测试性**：小组件更容易测试

---

## 4.2 组件 Props 传递

### 基础 Props

**定义组件：**

```typescript
// app/components/ui/Button.tsx
interface ButtonProps {
  children: React.ReactNode
  onClick?: () => void
  variant?: 'primary' | 'secondary'
  disabled?: boolean
}

export default function Button({
  children,
  onClick,
  variant = 'primary',
  disabled = false,
}: ButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`px-4 py-2 rounded ${variant === 'primary' ? 'bg-blue-500' : 'bg-gray-500'}`}
    >
      {children}
    </button>
  )
}
```

**使用组件：**

```typescript
import Button from '@/app/components/ui/Button'

export default function Page() {
  return (
    <div>
      <Button variant="primary" onClick={() => alert('点击')}>
        主要按钮
      </Button>
      <Button variant="secondary" disabled>
        禁用按钮
      </Button>
    </div>
  )
}
```

---

### Props 类型定义

**使用 TypeScript 定义 Props：**

```typescript
// app/components/UserCard.tsx
interface UserCardProps {
  name: string
  email: string
  avatar?: string // 可选属性
  age: number
  isActive: boolean
}

export default function UserCard({
  name,
  email,
  avatar,
  age,
  isActive,
}: UserCardProps) {
  return (
    <div className={`p-4 border rounded ${isActive ? 'bg-green-50' : 'bg-gray-50'}`}>
      {avatar && <img src={avatar} alt={name} className="w-16 h-16 rounded-full" />}
      <h3>{name}</h3>
      <p>{email}</p>
      <p>年龄: {age}</p>
      <span className={isActive ? 'text-green-600' : 'text-gray-600'}>
        {isActive ? '活跃' : '非活跃'}
      </span>
    </div>
  )
}
```

**使用组件：**

```typescript
import UserCard from '@/app/components/UserCard'

export default function Page() {
  return (
    <div>
      <UserCard
        name="张三"
        email="zhangsan@example.com"
        avatar="/avatar.jpg"
        age={25}
        isActive={true}
      />
    </div>
  )
}
```

---

### 传递函数作为 Props

```typescript
// app/components/ButtonGroup.tsx
interface ButtonGroupProps {
  buttons: Array<{
    label: string
    onClick: () => void
    variant?: 'primary' | 'secondary'
  }>
}

export default function ButtonGroup({ buttons }: ButtonGroupProps) {
  return (
    <div className="flex gap-2">
      {buttons.map((button, index) => (
        <button
          key={index}
          onClick={button.onClick}
          className={`px-4 py-2 rounded ${
            button.variant === 'primary' ? 'bg-blue-500' : 'bg-gray-500'
          }`}
        >
          {button.label}
        </button>
      ))}
    </div>
  )
}
```

**使用组件：**

```typescript
'use client'

import { useState } from 'react'
import ButtonGroup from '@/app/components/ButtonGroup'

export default function Page() {
  const [count, setCount] = useState(0)
  
  const buttons = [
    {
      label: '增加',
      onClick: () => setCount(count + 1),
      variant: 'primary' as const,
    },
    {
      label: '减少',
      onClick: () => setCount(count - 1),
      variant: 'secondary' as const,
    },
    {
      label: '重置',
      onClick: () => setCount(0),
    },
  ]
  
  return (
    <div>
      <p>计数: {count}</p>
      <ButtonGroup buttons={buttons} />
    </div>
  )
}
```

---

## 4.3 理解 children 的使用

### 基础 children

`children` 是 React 的特殊 prop，用于传递组件内容。

**定义组件：**

```typescript
// app/components/ui/Card.tsx
interface CardProps {
  children: React.ReactNode
  title?: string
}

export default function Card({ children, title }: CardProps) {
  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      {title && <h2 className="text-xl font-bold mb-4">{title}</h2>}
      <div>{children}</div>
    </div>
  )
}
```

**使用组件：**

```typescript
import Card from '@/app/components/ui/Card'

export default function Page() {
  return (
    <Card title="卡片标题">
      <p>这是卡片的内容</p>
      <button>按钮</button>
    </Card>
  )
}
```

---

### 多个 children（使用命名 slots）

```typescript
// app/components/ui/Modal.tsx
interface ModalProps {
  children: React.ReactNode
  header?: React.ReactNode
  footer?: React.ReactNode
}

export default function Modal({ children, header, footer }: ModalProps) {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg p-6 max-w-md w-full">
        {header && <div className="mb-4">{header}</div>}
        <div>{children}</div>
        {footer && <div className="mt-4">{footer}</div>}
      </div>
    </div>
  )
}
```

**使用组件：**

```typescript
import Modal from '@/app/components/ui/Modal'
import Button from '@/app/components/ui/Button'

export default function Page() {
  return (
    <Modal
      header={<h2 className="text-xl font-bold">确认删除</h2>}
      footer={
        <div className="flex gap-2 justify-end">
          <Button variant="secondary">取消</Button>
          <Button variant="danger">删除</Button>
        </div>
      }
    >
      <p>确定要删除这个项目吗？此操作不可撤销。</p>
    </Modal>
  )
}
```

---

### 使用 render props 模式

```typescript
// app/components/DataFetcher.tsx
interface DataFetcherProps<T> {
  fetchData: () => Promise<T>
  children: (data: T | null, loading: boolean, error: Error | null) => React.ReactNode
}

export default function DataFetcher<T>({
  fetchData,
  children,
}: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  
  useEffect(() => {
    fetchData()
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false))
  }, [fetchData])
  
  return <>{children(data, loading, error)}</>
}
```

**使用组件：**

```typescript
'use client'

import DataFetcher from '@/app/components/DataFetcher'

export default function Page() {
  const fetchUsers = async () => {
    const res = await fetch('/api/users')
    return res.json()
  }
  
  return (
    <DataFetcher fetchData={fetchUsers}>
      {(data, loading, error) => {
        if (loading) return <div>加载中...</div>
        if (error) return <div>错误: {error.message}</div>
        return (
          <ul>
            {data?.map((user: any) => (
              <li key={user.id}>{user.name}</li>
            ))}
          </ul>
        )
      }}
    </DataFetcher>
  )
}
```

---

## 4.4 实践：创建可复用的布局组件

### 示例 1：可复用的页面布局

**创建布局组件：** `app/components/layout/PageLayout.tsx`

```typescript
// app/components/layout/PageLayout.tsx
interface PageLayoutProps {
  children: React.ReactNode
  title?: string
  description?: string
  header?: React.ReactNode
  footer?: React.ReactNode
}

export default function PageLayout({
  children,
  title,
  description,
  header,
  footer,
}: PageLayoutProps) {
  return (
    <div className="min-h-screen flex flex-col">
      {/* 自定义头部 */}
      {header || (
        <header className="bg-blue-600 text-white p-4">
          <h1 className="text-2xl font-bold">{title || '默认标题'}</h1>
          {description && <p className="text-blue-100">{description}</p>}
        </header>
      )}
      
      {/* 主要内容 */}
      <main className="flex-1 container mx-auto p-8">
        {children}
      </main>
      
      {/* 自定义底部 */}
      {footer || (
        <footer className="bg-gray-800 text-white p-4 text-center">
          <p>&copy; 2024 我的网站</p>
        </footer>
      )}
    </div>
  )
}
```

**使用布局组件：**

```typescript
import PageLayout from '@/app/components/layout/PageLayout'

export default function AboutPage() {
  return (
    <PageLayout
      title="关于我们"
      description="了解我们的故事和使命"
    >
      <div>
        <h2>我们的故事</h2>
        <p>这是关于页面的内容...</p>
      </div>
    </PageLayout>
  )
}
```

---

### 示例 2：可复用的卡片网格

**创建组件：** `app/components/layout/CardGrid.tsx`

```typescript
// app/components/layout/CardGrid.tsx
interface CardGridProps {
  children: React.ReactNode
  columns?: 1 | 2 | 3 | 4
  gap?: 'sm' | 'md' | 'lg'
}

export default function CardGrid({
  children,
  columns = 3,
  gap = 'md',
}: CardGridProps) {
  const gridCols = {
    1: 'grid-cols-1',
    2: 'grid-cols-1 md:grid-cols-2',
    3: 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3',
    4: 'grid-cols-1 md:grid-cols-2 lg:grid-cols-4',
  }
  
  const gaps = {
    sm: 'gap-2',
    md: 'gap-4',
    lg: 'gap-6',
  }
  
  return (
    <div className={`grid ${gridCols[columns]} ${gaps[gap]}`}>
      {children}
    </div>
  )
}
```

**使用组件：**

```typescript
import CardGrid from '@/app/components/layout/CardGrid'
import Card from '@/app/components/ui/Card'

export default function ProductsPage() {
  const products = [
    { id: 1, name: '产品1', price: 100 },
    { id: 2, name: '产品2', price: 200 },
    { id: 3, name: '产品3', price: 300 },
  ]
  
  return (
    <CardGrid columns={3} gap="lg">
      {products.map((product) => (
        <Card key={product.id} title={product.name}>
          <p>价格: ¥{product.price}</p>
        </Card>
      ))}
    </CardGrid>
  )
}
```

---

### 示例 3：可复用的表单布局

**创建组件：** `app/components/forms/FormLayout.tsx`

```typescript
// app/components/forms/FormLayout.tsx
interface FormLayoutProps {
  children: React.ReactNode
  title?: string
  onSubmit?: (e: React.FormEvent) => void
  submitLabel?: string
  cancelLabel?: string
  onCancel?: () => void
}

export default function FormLayout({
  children,
  title,
  onSubmit,
  submitLabel = '提交',
  cancelLabel = '取消',
  onCancel,
}: FormLayoutProps) {
  return (
    <form onSubmit={onSubmit} className="max-w-2xl mx-auto p-6">
      {title && <h2 className="text-2xl font-bold mb-6">{title}</h2>}
      
      <div className="space-y-4 mb-6">
        {children}
      </div>
      
      <div className="flex gap-4 justify-end">
        {onCancel && (
          <button
            type="button"
            onClick={onCancel}
            className="px-4 py-2 border rounded"
          >
            {cancelLabel}
          </button>
        )}
        <button
          type="submit"
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          {submitLabel}
        </button>
      </div>
    </form>
  )
}
```

**使用组件：**

```typescript
'use client'

import { useState } from 'react'
import FormLayout from '@/app/components/forms/FormLayout'
import Input from '@/app/components/ui/Input'

export default function ContactPage() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: '',
  })
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    console.log('提交:', formData)
  }
  
  return (
    <FormLayout
      title="联系我们"
      onSubmit={handleSubmit}
      onCancel={() => {
        setFormData({ name: '', email: '', message: '' })
      }}
    >
      <Input
        label="姓名"
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
      />
      <Input
        label="邮箱"
        type="email"
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
      />
      <div>
        <label className="block text-sm font-medium mb-1">留言</label>
        <textarea
          value={formData.message}
          onChange={(e) => setFormData({ ...formData, message: e.target.value })}
          className="w-full px-4 py-2 border rounded"
          rows={4}
        />
      </div>
    </FormLayout>
  )
}
```

---

## 4.5 高级组合模式

### 模式 1：组件作为 Props

```typescript
// app/components/ui/Container.tsx
interface ContainerProps {
  children: React.ReactNode
  header?: React.ComponentType<{ title: string }>
  title: string
}

export default function Container({
  children,
  header: Header,
  title,
}: ContainerProps) {
  return (
    <div className="container mx-auto p-8">
      {Header ? <Header title={title} /> : <h1>{title}</h1>}
      <div>{children}</div>
    </div>
  )
}
```

**使用组件：**

```typescript
const CustomHeader = ({ title }: { title: string }) => (
  <div className="bg-blue-500 text-white p-4 rounded mb-4">
    <h1 className="text-2xl">{title}</h1>
  </div>
)

export default function Page() {
  return (
    <Container title="页面标题" header={CustomHeader}>
      <p>页面内容</p>
    </Container>
  )
}
```

---

### 模式 2：复合组件模式

```typescript
// app/components/ui/Accordion.tsx
interface AccordionContextType {
  openIndex: number | null
  setOpenIndex: (index: number | null) => void
}

const AccordionContext = React.createContext<AccordionContextType | null>(null)

interface AccordionProps {
  children: React.ReactNode
}

export function Accordion({ children }: AccordionProps) {
  const [openIndex, setOpenIndex] = useState<number | null>(null)
  
  return (
    <AccordionContext.Provider value={{ openIndex, setOpenIndex }}>
      <div className="space-y-2">{children}</div>
    </AccordionContext.Provider>
  )
}

interface AccordionItemProps {
  children: React.ReactNode
  index: number
}

export function AccordionItem({ children, index }: AccordionItemProps) {
  const context = useContext(AccordionContext)
  if (!context) throw new Error('AccordionItem must be inside Accordion')
  
  const { openIndex, setOpenIndex } = context
  const isOpen = openIndex === index
  
  return (
    <div className="border rounded">
      <button
        onClick={() => setOpenIndex(isOpen ? null : index)}
        className="w-full p-4 text-left flex justify-between"
      >
        <span>标题 {index + 1}</span>
        <span>{isOpen ? '−' : '+'}</span>
      </button>
      {isOpen && <div className="p-4">{children}</div>}
    </div>
  )
}
```

**使用组件：**

```typescript
'use client'

import { Accordion, AccordionItem } from '@/app/components/ui/Accordion'

export default function Page() {
  return (
    <Accordion>
      <AccordionItem index={0}>
        <p>这是第一项的内容</p>
      </AccordionItem>
      <AccordionItem index={1}>
        <p>这是第二项的内容</p>
      </AccordionItem>
      <AccordionItem index={2}>
        <p>这是第三项的内容</p>
      </AccordionItem>
    </Accordion>
  )
}
```

---

## 4.6 组件组合最佳实践

### 实践 1：单一职责原则

```typescript
// ✅ 推荐：每个组件职责单一
function Button({ children, onClick }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>
}

function Card({ children, title }: CardProps) {
  return (
    <div>
      {title && <h2>{title}</h2>}
      {children}
    </div>
  )
}

// ❌ 不推荐：组件职责过多
function ButtonCard({ children, onClick, title }: ButtonCardProps) {
  // 混合了按钮和卡片的职责
}
```

### 实践 2：使用 TypeScript 定义 Props

```typescript
// ✅ 推荐：使用 TypeScript 定义 Props
interface UserCardProps {
  name: string
  email: string
  age?: number
}

export default function UserCard({ name, email, age }: UserCardProps) {
  // ...
}

// ❌ 不推荐：不使用类型定义
export default function UserCard(props: any) {
  // ...
}
```

### 实践 3：合理使用 children

```typescript
// ✅ 推荐：使用 children 提高灵活性
function Card({ children, title }: CardProps) {
  return (
    <div>
      {title && <h2>{title}</h2>}
      {children}
    </div>
  )
}

// 使用
<Card title="标题">
  <p>内容1</p>
  <p>内容2</p>
</Card>

// ❌ 不推荐：硬编码内容
function Card({ title, content }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      <p>{content}</p> // 只能显示一个段落
    </div>
  )
}
```

---

## 4.7 常见问题解答

### Q1：什么时候应该使用 children？

**A：** 当组件需要灵活的内容时使用 children：
- 布局组件（Card、Modal、Container）
- 包装组件（Provider、Wrapper）
- 需要动态内容的组件

### Q2：如何传递多个 children？

**A：** 可以使用命名 props 或 render props 模式：

```typescript
// 方式 1：命名 props
function Modal({ header, body, footer }: ModalProps) { ... }

// 方式 2：render props
function DataFetcher({ children }: { children: (data) => ReactNode }) { ... }
```

### Q3：组件组合 vs 组件继承？

**A：** React 推荐使用组合而不是继承：
- ✅ 组合：更灵活，易于维护
- ❌ 继承：在 React 中不常用，可能导致复杂的继承链

---

## 4.8 总结

### 关键要点

1. **Props 传递**：通过 props 向组件传递数据和函数
2. **children 使用**：使用 children 实现灵活的内容组合
3. **组合模式**：通过组合小组件构建大组件
4. **最佳实践**：单一职责、TypeScript 类型、合理使用 children

### 下一步

完成组件组合模式学习后，可以学习样式管理，了解如何使用 Tailwind CSS 美化组件。

---

**学习进度：** ✅ 组件组合模式学习完成

