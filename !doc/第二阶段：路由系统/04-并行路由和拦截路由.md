# 并行路由和拦截路由

> ⚠️ **重要提示**：这是 Next.js 的高级特性，在实际项目中**很少使用**。如果觉得难以理解，可以先跳过，专注于掌握基础路由功能。这些特性可以在需要时再深入学习。

---

## 📚 第一部分：并行路由（Parallel Routes）

### 1.1 用最简单的方式理解并行路由

**生活化比喻：**

想象你有一个房间（页面），房间里可以同时放置：
- 一张桌子（主要内容）
- 一个书架（侧边栏数据）
- 一个白板（团队成员列表）

并行路由就是让你可以**同时**在页面上显示多个不同的内容区域，每个区域都是独立的"路由"。

### 1.2 普通方式 vs 并行路由

#### 方式一：普通方式（所有内容写在一起）

```typescript
// app/dashboard/page.tsx
export default function DashboardPage() {
  return (
    <div>
      <main>
        <h1>主要内容</h1>
        <p>这是仪表板的主要内容</p>
      </main>
      <aside>
        <h2>分析数据</h2>
        <p>访问量: 1000</p>
      </aside>
      <aside>
        <h2>团队成员</h2>
        <ul>
          <li>张三</li>
          <li>李四</li>
        </ul>
      </aside>
    </div>
  )
}
```

**问题**：
- 所有代码都写在一个文件里
- 如果分析数据加载慢，整个页面都要等待
- 难以独立管理每个部分

#### 方式二：并行路由（内容分开管理）

**目录结构：**

```text
app/
├── @analytics/        # 分析数据（独立的"路由"）
│   └── page.tsx
├── @team/            # 团队成员（独立的"路由"）
│   └── page.tsx
└── dashboard/
    ├── layout.tsx    # 布局：把三个部分组合在一起
    └── page.tsx      # 主要内容
```

**关键理解**：
- `@analytics` 和 `@team` 是**并行路由槽位**（使用 `@` 符号）
- 它们的内容会**同时**传递给 `dashboard/layout.tsx`
- 布局组件可以决定如何排列这些内容

### 1.3 完整示例：一步一步创建并行路由

#### 步骤 1：创建分析数据槽位

```typescript
// app/@analytics/page.tsx
export default async function AnalyticsPage() {
  // 这个组件会独立加载数据
  const data = await fetch('https://api.example.com/analytics')
    .then(res => res.json())
  
  return (
    <div className="bg-blue-50 p-4 rounded">
      <h2 className="text-lg font-bold mb-2">📊 分析数据</h2>
      <p>访问量: {data.views}</p>
      <p>用户数: {data.users}</p>
    </div>
  )
}
```

#### 步骤 2：创建团队成员槽位

```typescript
// app/@team/page.tsx
export default async function TeamPage() {
  // 这个组件也会独立加载数据
  const team = await fetch('https://api.example.com/team')
    .then(res => res.json())
  
  return (
    <div className="bg-green-50 p-4 rounded">
      <h2 className="text-lg font-bold mb-2">👥 团队成员</h2>
      <ul>
        {team.map(member => (
          <li key={member.id}>{member.name}</li>
        ))}
      </ul>
    </div>
  )
}
```

#### 步骤 3：创建主要内容

```typescript
// app/dashboard/page.tsx
export default function DashboardPage() {
  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">📈 仪表板</h1>
      <p>这是仪表板的主要内容区域</p>
    </div>
  )
}
```

#### 步骤 4：在布局中组合所有部分

```typescript
// app/dashboard/layout.tsx
export default function DashboardLayout({
  children,      // 来自 dashboard/page.tsx（主要内容）
  analytics,      // 来自 @analytics/page.tsx（分析数据）
  team,           // 来自 @team/page.tsx（团队成员）
}: {
  children: React.ReactNode
  analytics: React.ReactNode    // ⚠️ 注意：prop 名称 = 文件夹名称去掉 @
  team: React.ReactNode
}) {
  return (
    <div className="flex gap-4 p-4">
      {/* 左侧：主要内容 */}
      <main className="flex-1 bg-white p-6 rounded shadow">
        {children}
      </main>
      
      {/* 右侧：两个侧边栏 */}
      <div className="w-80 space-y-4">
        {analytics}  {/* 分析数据 */}
        {team}       {/* 团队成员 */}
      </div>
    </div>
  )
}
```

#### 最终效果

当访问 `/dashboard` 时，页面会同时显示：

```
┌─────────────────────────────────────────┐
│  主要内容区域          │  分析数据        │
│  (children)           │  (analytics)   │
│  📈 仪表板            │  📊 分析数据    │
│  这是主要内容...      │  访问量: 1000   │
│                       │  用户数: 500    │
│                       │                │
│                       │  团队成员        │
│                       │  (team)         │
│                       │  👥 团队成员     │
│                       │  • 张三         │
│                       │  • 李四         │
└─────────────────────────────────────────┘
```

### 1.4 关键理解点

#### 理解点 1：槽位名称和 prop 的对应关系

```text
文件夹名称          →  layout 中的 prop 名称
@analytics/        →  analytics
@team/             →  team
@sidebar/          →  sidebar
```

**规则**：去掉 `@` 符号，就是 prop 名称。

#### 理解点 2：所有槽位都会同时渲染

当访问 `/dashboard` 时：
1. Next.js 会同时加载三个路由：
   - `dashboard/page.tsx` → `children`
   - `@analytics/page.tsx` → `analytics`
   - `@team/page.tsx` → `team`
2. 所有内容都传递给 `dashboard/layout.tsx`
3. 布局组件决定如何排列这些内容

#### 理解点 3：每个槽位独立加载

**优势**：
- 如果分析数据加载慢，主要内容可以先显示
- 如果团队成员加载慢，不影响其他部分
- 每个部分可以独立设置加载状态

### 1.5 实际应用场景

**场景：电商产品详情页**

```text
app/
├── @related/          # 相关产品
│   └── page.tsx
├── @reviews/          # 用户评论
│   └── page.tsx
└── products/
    └── [id]/
        ├── layout.tsx  # 组合三个部分
        └── page.tsx   # 产品详情
```

**效果**：
- 产品详情（主要内容）
- 相关产品（侧边栏）
- 用户评论（底部）

---

## 📚 第二部分：拦截路由（Intercepting Routes）

### 2.1 用最简单的方式理解拦截路由

**生活化比喻：**

想象你在看一本书（照片列表页）：
- **普通方式**：点击照片 → 翻到新的一页（跳转到新页面）
- **拦截路由**：点击照片 → 在当前页面上弹出一个小窗口显示照片（不翻页，但书签位置变了）

**关键区别**：
- URL 会变化（书签位置变了）
- 但页面不跳转（不翻页）
- 用模态框显示内容（弹出窗口）

### 2.2 普通方式 vs 拦截路由

#### 方式一：普通路由（跳转页面）

```typescript
// app/photos/page.tsx - 照片列表
import Link from 'next/link'

export default function PhotosPage() {
  return (
    <div>
      <h1>照片列表</h1>
      <Link href="/photos/1">
        <img src="/photo1.jpg" />
      </Link>
    </div>
  )
}
```

**用户体验**：
```
照片列表 → 点击照片 → 跳转到新页面 → 显示照片详情
（页面刷新，需要重新加载）
```

#### 方式二：拦截路由（弹出模态框）

**目录结构：**

```text
app/
├── @modal/                    # 模态框槽位
│   └── (.)photos/            # 拦截 /photos/[id]
│       └── [id]/
│           └── page.tsx      # 模态框内容
├── photos/
│   ├── page.tsx              # 照片列表
│   └── [id]/
│       └── page.tsx          # 照片详情（正常路由）
└── layout.tsx                # 接收 @modal 槽位
```

**用户体验**：
```
照片列表 → 点击照片 → 弹出模态框显示照片 → 关闭模态框 → 还在列表页
（页面不刷新，体验更流畅）
```

### 2.3 完整示例：一步一步创建拦截路由

#### 场景说明

- 照片列表页：`/photos`
- 照片详情页：`/photos/1`、`/photos/2` 等
- **需求**：点击照片时，希望弹出模态框，而不是跳转

#### 步骤 1：创建照片列表页

```typescript
// app/photos/page.tsx
import Link from 'next/link'

export default function PhotosPage() {
  const photos = [
    { id: 1, title: '照片 1', url: '/photo1.jpg' },
    { id: 2, title: '照片 2', url: '/photo2.jpg' },
    { id: 3, title: '照片 3', url: '/photo3.jpg' }
  ]
  
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-4">📷 照片列表</h1>
      <div className="grid grid-cols-3 gap-4">
        {photos.map(photo => (
          <Link 
            key={photo.id} 
            href={`/photos/${photo.id}`}  // 正常链接
          >
            <img 
              src={photo.url} 
              alt={photo.title}
              className="cursor-pointer hover:opacity-80"
            />
          </Link>
        ))}
      </div>
    </div>
  )
}
```

#### 步骤 2：创建照片详情页（正常路由）

```typescript
// app/photos/[id]/page.tsx
export default async function PhotoPage({
  params,
}: {
  params: { id: string }
}) {
  // 如果用户直接访问 /photos/1，会显示这个页面
  const photo = await fetch(`https://api.example.com/photos/${params.id}`)
    .then(res => res.json())
  
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold">{photo.title}</h1>
      <img src={photo.url} alt={photo.title} className="mt-4" />
      <p className="mt-4">{photo.description}</p>
    </div>
  )
}
```

#### 步骤 3：创建拦截路由（模态框版本）

```typescript
// app/@modal/(.)photos/[id]/page.tsx
'use client'  // 必须是客户端组件（因为需要交互）

import { useRouter } from 'next/navigation'

export default function PhotoModal({
  params,
}: {
  params: { id: string }
}) {
  const router = useRouter()
  
  return (
    // 模态框背景（半透明黑色）
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      onClick={() => router.back()}  // 点击背景关闭
    >
      {/* 模态框内容 */}
      <div 
        className="bg-white p-8 max-w-2xl rounded-lg shadow-xl"
        onClick={(e) => e.stopPropagation()}  // 阻止点击事件冒泡
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">照片 {params.id}</h2>
          <button 
            onClick={() => router.back()}
            className="text-gray-500 hover:text-gray-700"
          >
            ✕ 关闭
          </button>
        </div>
        <img 
          src={`/photo${params.id}.jpg`} 
          alt={`照片 ${params.id}`}
          className="w-full"
        />
        <p className="mt-4">这是模态框版本的照片详情</p>
      </div>
    </div>
  )
}
```

#### 步骤 4：在根布局中接收模态框

```typescript
// app/layout.tsx
export default function RootLayout({
  children,
  modal,  // 来自 @modal 槽位
}: {
  children: React.ReactNode
  modal: React.ReactNode
}) {
  return (
    <html>
      <body>
        {children}  {/* 主要内容 */}
        {modal}     {/* 模态框（如果有的话） */}
      </body>
    </html>
  )
}
```

### 2.4 工作原理：详细说明

#### 场景 1：用户访问照片列表

**URL：** `/photos`

**发生什么：**
1. 显示 `photos/page.tsx` 的内容（照片列表）
2. `@modal` 槽位没有匹配的路由，所以 `modal` 是 `null`
3. 页面正常显示，没有模态框

#### 场景 2：用户点击照片

**URL 变化：** `/photos` → `/photos/1`

**发生什么：**
1. **拦截路由生效**：
   - `@modal/(.)photos/[id]/page.tsx` 匹配 `/photos/1`
   - 这个组件被渲染为模态框
   - 传递给根布局的 `modal` prop

2. **正常路由也准备**：
   - `photos/[id]/page.tsx` 也在后台准备
   - 如果用户直接访问 `/photos/1`（不是从列表点击），会显示这个页面

3. **页面不跳转**：
   - URL 变成了 `/photos/1`
   - 但页面不刷新
   - 照片列表还在，只是上面覆盖了一个模态框

**视觉效果：**
```
┌─────────────────────────────┐
│  照片列表（背景，变暗）      │
│  [照片1] [照片2] [照片3]    │
│                             │
│      ┌───────────────┐      │
│      │  模态框       │      │
│      │  照片 1       │      │
│      │  [图片]       │      │
│      │  ✕ 关闭      │      │
│      └───────────────┘      │
└─────────────────────────────┘
```

#### 场景 3：用户关闭模态框

**操作：** 点击"关闭"按钮或点击背景

**发生什么：**
1. 调用 `router.back()`
2. URL 变回 `/photos`
3. 模态框消失（因为 `@modal` 没有匹配的路由了）
4. 回到照片列表页

### 2.5 拦截路由语法详解

#### 语法对照表

| 语法 | 含义 | 示例 | 拦截的目标 |
|------|------|------|-----------|
| `(.)` | 同一层级 | `@modal/(.)photos/[id]` | `photos/[id]` |
| `(..)` | 上一层级 | `dashboard/@modal/(..)photos/[id]` | `photos/[id]` |
| `(..)(..)` | 上两级 | `dashboard/settings/@modal/(..)(..)photos/[id]` | `photos/[id]` |
| `(...)` | 根路由 | `@modal/(...)photos/[id]` | `photos/[id]` |

#### 实际目录结构示例

**示例 1：同一层级拦截**

```text
app/
├── @modal/
│   └── (.)photos/          # (.) 表示和 @modal 同一层级
│       └── [id]/
│           └── page.tsx    # 拦截 app/photos/[id]/page.tsx
└── photos/
    └── [id]/
        └── page.tsx        # 正常路由
```

**示例 2：上一层级拦截**

```text
app/
├── dashboard/
│   └── @modal/
│       └── (..)photos/     # (..) 表示上一层级
│           └── [id]/
│               └── page.tsx # 拦截 app/photos/[id]/page.tsx
└── photos/
    └── [id]/
        └── page.tsx        # 正常路由
```

### 2.6 为什么需要拦截路由？

**传统方式的问题：**

```
用户浏览照片列表
  ↓
点击照片
  ↓
跳转到新页面（页面刷新）
  ↓
查看照片详情
  ↓
点击返回
  ↓
回到列表（页面又刷新）
```

**使用拦截路由的优势：**

```
用户浏览照片列表
  ↓
点击照片
  ↓
弹出模态框（页面不刷新，体验流畅）
  ↓
查看照片详情
  ↓
关闭模态框
  ↓
还在列表页（不需要重新加载）
```

**用户体验提升：**
- ✅ 页面不刷新，加载更快
- ✅ 保持当前页面的上下文
- ✅ 更流畅的交互体验

---

## 📚 第三部分：常见问题解答

### Q1: 并行路由和普通布局有什么区别？

**普通布局：**
```typescript
// 所有内容写在一个组件里
export default function Layout({ children }) {
  return (
    <div>
      <main>{children}</main>
      <aside>侧边栏内容</aside>  {/* 写死在这里 */}
    </div>
  )
}
```

**并行路由：**
```typescript
// 内容分开管理，通过 props 传递
export default function Layout({ children, sidebar }) {
  return (
    <div>
      <main>{children}</main>
      <aside>{sidebar}</aside>  {/* 来自独立的路由 */}
    </div>
  )
}
```

**区别：**
- 并行路由：内容独立管理，可以独立加载
- 普通布局：所有内容写在一起

### Q2: 拦截路由和普通路由有什么区别？

**普通路由：**
- 点击链接 → 跳转到新页面
- URL 变化，页面刷新

**拦截路由：**
- 点击链接 → 弹出模态框
- URL 变化，但页面不刷新

### Q3: 什么时候使用并行路由？

**使用场景：**
- ✅ 需要同时显示多个独立的内容区域
- ✅ 需要为不同部分设置独立的加载状态
- ✅ 需要独立管理不同部分的代码

**实际例子：**
- 仪表板：主要内容 + 侧边栏数据 + 团队成员
- 产品页：产品详情 + 相关产品 + 用户评论

### Q4: 什么时候使用拦截路由？

**使用场景：**
- ✅ 需要创建模态框（照片、文章预览等）
- ✅ 需要创建侧边栏（购物车、导航等）
- ✅ 希望改善用户体验（不跳转页面）

**实际例子：**
- 照片画廊：点击照片弹出模态框
- 博客列表：点击文章弹出预览
- 购物车：点击按钮侧边栏滑出

### Q5: 并行路由和拦截路由可以一起用吗？

**可以！** 实际上，拦截路由通常需要配合并行路由使用。

**示例：**
```text
app/
├── @modal/              # 并行路由槽位
│   └── (.)photos/      # 拦截路由
│       └── [id]/
│           └── page.tsx
└── photos/
    └── [id]/
        └── page.tsx
```

`@modal` 是并行路由槽位，`(.)photos` 是拦截路由语法。

---

## 📚 第四部分：学习建议

### 4.1 是否需要学习这些特性？

**建议：**

1. **先掌握基础**：
   - ✅ 静态路由
   - ✅ 动态路由
   - ✅ 路由组
   - ✅ 导航

2. **再学习高级特性**（可选）：
   - 📚 并行路由
   - 📚 拦截路由

3. **实际应用**：
   - 大多数项目**不需要**这些高级特性
   - 但在特定场景下非常有用
   - 可以先跳过，需要时再学

### 4.2 如果还是不理解怎么办？

**没关系！** 这些是高级特性，可以：

1. **先跳过**：专注于掌握基础路由功能
2. **需要时再学**：当实际项目中需要用到时再深入学习
3. **参考官方文档**：Next.js 官方文档有更详细的说明

---

## 📚 总结

### 并行路由要点

1. **作用**：同时渲染多个独立的路由内容
2. **语法**：使用 `@folder` 创建槽位
3. **使用**：在布局中通过 props 接收并渲染
4. **优势**：内容独立管理，可以独立加载

### 拦截路由要点

1. **作用**：拦截路由请求，用不同 UI 显示（如模态框）
2. **语法**：使用 `(.)`、`(..)` 等语法
3. **效果**：URL 变化，但页面不跳转
4. **优势**：改善用户体验，更流畅的交互

### 关键记忆

- **并行路由** = 同时显示多个内容（多个"窗口"）
- **拦截路由** = 拦截跳转，显示模态框（不跳转页面）

---

**最后提醒**：如果这些概念仍然难以理解，完全可以先跳过。这些高级特性在实际项目中不常用，可以在需要时再深入学习。先掌握基础路由功能更重要！
